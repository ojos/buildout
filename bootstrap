#!/usr/bin/env python
# -*- coding: utf-8 -*-
import argparse
import json
import os
import shutil
import StringIO
import subprocess
import sys
import tempfile
import time
import urllib2
import yaml

try:
    import configparser
except:
    import ConfigParser as configparser

config_path = './buildout.cfg'
homebrew_url = 'https://raw.githubusercontent.com/Homebrew/install/master/install'
pip_url = 'https://bootstrap.pypa.io/get-pip.py'


def _loading(current=None):
    loading_frames = ['|', '/', '-', '\\']
    current = 0 if current is None or current == len(loading_frames) - 1 else current + 1
    sys.stdout.write("\rwaiting : %s" % loading_frames[current])
    sys.stdout.flush()
    return current


def _install_CLT():
    print 'install command line tools...'

    subprocess.Popen(['xcode-select', '--install'],
                     stdin=subprocess.PIPE,
                     stdout=subprocess.PIPE,
                     stderr=subprocess.PIPE,
                     shell=False)
    progress = None

    while True:
        p = subprocess.Popen(['gcc', '-v'],
                             stdin=subprocess.PIPE,
                             stdout=subprocess.PIPE,
                             stderr=subprocess.PIPE,
                             shell=False)
        if p.wait() == 0:
            print 'command line tools had been installed!!'
            break
        else:
            progress = _loading(progress)
            time.sleep(0.5)


def _install_homebrew():
    print 'install homebrew...'

    res = urllib2.urlopen(homebrew_url)
    codes = res.read()
    subprocess.call(['ruby', '-e', codes], shell=False)


def _change_zsh():
    print 'change login shell...'

    if os.environ['SHELL'] != '/bin/zsh':
        subprocess.call(['chsh', '-s', '/bin/zsh'], shell=False)
    else:
        print 'login shell had been changed!!'


def _install_pip():
    try:
        import pip
    except:
        print 'install pip...'

        res = urllib2.urlopen(pip_url)
        codes = res.read()
        fh = tempfile.NamedTemporaryFile()
        fh.write(codes)
        fh.flush()
        subprocess.call(['sudo', 'python', fh.name], shell=False)


def _install_ansible():
    try:
        import ansible
    except:
        print 'install ansible from pip...'
        subprocess.call(['sudo', 'pip', 'install', 'ansible'], shell=False)


def _clean_ansible_roles(roles_dir):
    if os.path.exists(roles_dir):
        print 'remove roles dir...'
        shutil.rmtree(roles_dir)


def _clone_ansible_roles(roles_repository, roles_dir):
    _clean_ansible_roles(roles_dir)

    subprocess.call(['git', 'clone', roles_repository, roles_dir], shell=False)


def _generate_ansible_config(config):
    config_fh = tempfile.NamedTemporaryFile()
    config_fh.write(config['ansible']['config'])
    config_fh.flush()

    conf = configparser.SafeConfigParser()
    conf.read(config_fh.name)

    if conf.has_option('defaults', 'roles_path'):
        roles = conf.get('defaults', 'roles_path').split(':')
    else:
        roles = []
    roles.extend([role['directory'] for role in config['ansible']['roles']])
    conf.set('defaults', 'roles_path', ':'.join(roles))

    config_fh.seek(0)
    conf.write(config_fh)
    config_fh.flush()

    return config_fh.name


def _generate_ansible_extra_vars(config):
    extra_vars = {}
    for pk, pv in config.items():
        if pk != 'ansible':
            for ck, cv in pv.items():
                extra_vars['%s_%s' % (pk, ck)] = cv
    print extra_vars


def _generate_ansible_playbook(config):
    pass


def _excute_ansible_playbook(config, passward):
    os.environ["ANSIBLE_CONFIG"] = _generate_ansible_config(config)
    import ansible
    import ansible.inventory
    import ansible.playbook

    stats = ansible.callbacks.AggregateStats()
    kwargs = {'stats': stats,
              # 'callbacks': ansible.callbacks.PlaybookCallbacks(),
              # 'runner_callbacks': ansible.callbacks.PlaybookRunnerCallbacks(stats),
              'inventory': ansible.inventory.Inventory(['localhost']),
              'extra_vars': _generate_ansible_extra_vars(config)}

    print kwargs

    # playbook_yml = config['ansible']['playbook_template']
    # if passward:
    #     playbook_yml[0]['roles'] = config['ansible']['playbook_roles']['advance']
    #     kwargs['vault_password'] = passward
    # else:
    #     playbook_yml[0]['roles'] = config['ansible']['playbook_roles']['basic']

    # playbook_fh = tempfile.NamedTemporaryFile()
    # playbook_fh.write(yaml.dump(playbook_yml))
    # playbook_fh.flush()
    # kwargs['playbook'] = playbook_fh.name
    # playbook = ansible.playbook.PlayBook(**kwargs)

    # try:
    #     playbook.run()
    # except Exception as e:
    #     print 'Ansible Error: %s' % e.message


def _main(config, passward):
    # _install_CLT()
    # _install_homebrew()
    # _change_zsh()
    # _install_pip()
    # _install_ansible()
    # for role in config['ansible']['roles']:
    #     _clone_ansible_roles(role['repository'], role['directory'])
    _excute_ansible_playbook(config, passward)


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description=u'Build environment on OSX')
    parser.add_argument('-c', '--config',
                        action='store',
                        default=config_path,
                        type=str,
                        help='Configuration file path (default: %s)' % config_path)
    parser.add_argument('-p', '--passward',
                        action='store',
                        help='Personal playbook execution flag (default: Fasle)')
    args = parser.parse_args()

    with open(args.config, 'r') as file:
        config = yaml.load(file)

    _main(config, args.passward)
